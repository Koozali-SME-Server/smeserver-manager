#
# Generated by SM2Gen version:0.9(20Jan2025) Chameleon version:4.5.4 On Python:3.12.3 at 2025-06-15 12:45:47 
#
#
# Routines to be edited by the developer to provide content and validation for parameters
# and provison of the control data for table(s)
#
use esmith::util;
use esmith::util::network;
use esmith::ConfigDB::UTF8;
use esmith::AccountsDB;
use esmith::NetworksDB::UTF8;
use esmith::HostsDB;
use esmith::DomainsDB::UTF8;

use DateTime;

use constant FALSE => 0;
use constant TRUE  => 1;


#The most common ones - open DB when required.
my $cdb; 
my $adb; 
my $ndb; 
my $hdb; 
my $ddb; 

#The most common ones - you might want to use these if you need to make sure that the DB is refreshed.
#$cdb = esmith::ConfigDB::UTF8->open()   || die("Couldn't open config db");
#$adb = esmith::AccountsDB->open() || die("Couldn't open Accounts db");
#$ndb = esmith::NetworksDB->open() || die("Couldn't open Network db");
#$hdb = esmith::HostsDB::UTF8->open() 	  || die("Couldn't open Hosts db");
#$ddb = esmith::DomainsDB::UTF8->open()  || die("Couldn't open Domains db");


# Validation routines - parameters for each panel

	sub validate_PARAMS {
		my $c = shift;
		my $dat_data = shift; #Data hash as parameter
		# Validation for each field 
		my $ret = '';
		
		if (! TRUE) #validate $c->param('time_mode')
			{$ret .= 'Validation for time_mode failed';}	
		if (! TRUE) #validate $c->param('ntpserver')
			{$ret .= 'Validation for ntpserver failed';}	
		if (! TRUE) #validate $c->param('year')
			{$ret .= 'Validation for year failed';}	
		if (! TRUE) #validate $c->param('month')
			{$ret .= 'Validation for month failed';}	
		if (! TRUE) #validate $c->param('day')
			{$ret .= 'Validation for day failed';}	
		if (! TRUE) #validate $c->param('hour')
			{$ret .= 'Validation for hour failed';}	
		if (! TRUE) #validate $c->param('minute')
			{$ret .= 'Validation for minute failed';}	
		if (! TRUE) #validate $c->param('second')
			{$ret .= 'Validation for second failed';}	
		if ($ret eq '') {$ret = 'ok';}
		return $ret;
	}


# Get singleton data for each panel

	sub get_data_for_panel_PARAMS {
		# Return a hash with the fields required which will be loaded into the shared data 
		my $c = shift;
		$cdb = esmith::ConfigDB::UTF8->open()   || die("Couldn't open config db");
		# --- Setup options ---
		# Get today's date and time
		my ($today_sec, $today_min, $today_hour, $today_mday, $today_mon, $today_year) = localtime;
		$today_year  += 1900;
		$today_mon   += 1;
		my $today_mon = sprintf('%02d', $today_mon);
		my $today_mday   = sprintf('%02d', $today_mday);
		my $now_hour    = sprintf('%02d', $today_hour);
		my $now_min     = sprintf('%02d', $today_min);
		my $now_sec     = sprintf('%02d', $today_sec);
		my $current_year = $today_year;
		my $ntpserverurl = $cdb->get_prop('ntpd','NTPServer');
		my $now = DateTime->now( time_zone => 'local' );
		my %ret = (
			# fields from Inputs 
			'time_mode'=>($ntpserverurl eq '' ? 'dat_manually_set' : 'dat_ntp_server'),
			'ntpserver'=>"$ntpserverurl",
			'year'=>"$today_year",
			'month'=>"$today_mon",
			'day'=>"$today_mday",,
			'hour'=>"$now_hour",
			'minute'=>"$now_min",
			'second'=>"$now_sec",
			'ntpstatus' => $cdb->get_prop('ntpd','status') || 'disabled',
			# and the current time as a full format 
			'currentdatetime' => $now->strftime('%Y-%m-%dT%H:%M:%S')
			
		);
		return %ret;
	}



# Get control data for table(s)



# Return hash with values from row in which link clicked on table

	sub get_selected_PARAMS {
		my $c = shift;
		my $selected = shift; #Parameter is name of selected row.
		my $is_new_record = shift; #Indicates new record required (defaults)
		my %ret = ();
		#gather the values here
		return %ret;
	}


#after sucessful modify or create or whatever and submit then perfom (if the params validate)

	sub perform_PARAMS {
		my $c = shift;
		my $dat_data = shift; #Data hash as parameter
		my $ret = '';
		$cdb = esmith::ConfigDB::UTF8->open()   || die("Couldn't open config db");
		my $db = $cdb; #maybe one of the others
		my $dbkey = 'ntpd';
		# To make it write to DB as comment, delete this (regex) string in each if statement "TRUE\) \#copy or perform with value: .* e.g."
		#$ntpserverurl = ( $c->param('time_mode') eq 'dat_manually_set' ? '' : $c->param('ntpserver'));
		#if (!$db->set_prop($dbkey,'NTPServer',$ntpserverurl,type=>'service'))
			#{$ret .= 'Perform/save failed for NTPServer';}
		#if (! TRUE) #copy or perform with value: year e.g. $db->set_prop($dbkey,'year',$c->param('year'),type=>'service'))
			#{$ret .= 'Perform/save failed for year';}
		#if (! TRUE) #copy or perform with value: month e.g. $db->set_prop($dbkey,'month',$c->param('month'),type=>'service'))
			#{$ret .= 'Perform/save failed for month';}
		#if (! TRUE) #copy or perform with value: day e.g. $db->set_prop($dbkey,'day',$c->param('day'),type=>'service'))
			#{$ret .= 'Perform/save failed for day';}
		#if (! TRUE) #copy or perform with value: hour e.g. $db->set_prop($dbkey,'hour',$c->param('hour'),type=>'service'))
			#{$ret .= 'Perform/save failed for hour';}
		#if (! TRUE) #copy or perform with value: minute e.g. $db->set_prop($dbkey,'minute',$c->param('minute'),type=>'service'))
			#{$ret .= 'Perform/save failed for minute';}
		#if (! TRUE) #copy or perform with value: second e.g. $db->set_prop($dbkey,'second',$c->param('second'),type=>'service'))
			#{$ret .= 'Perform/save failed for second';}
		if ($c->param('time_mode') eq 'dat_manually_set'){
			# Time and date set manually
			$ret .= $c->disable_ntp();
			$ret .= $c->validate_change_datetime()
		} else {
			# Time set by ntp server - set up parameters to it
			$ret = $c->update_ntpserver($c->param('ntpserver'))
		}
		if ($ret eq '') {$ret = 'ok';}
		return $ret;
	}


sub create_link{
	# WIP
	my ($c,$route, $panel, $index) = @_;
	my $link = "$route?trt=$panel&Selected=$index";
	return $link;
}

sub getZone_list {
    my $c = shift;

    #--------------------------------------------------
    # Get a sorted list of time zones
    #--------------------------------------------------
    $ENV{BASH_ENV} = '';

    if (!open(ZONES, "cd /usr/share/zoneinfo; /usr/bin/find . -type f -or -type l | /bin/grep '^./[A-Z]' |")) {
        warn($c->l('COULD_NOT_OPEN_TZ_FILE') . $! . '.');
        return undef;
    }
    my $zone;
    my @zones = ();

    while (defined($zone = <ZONES>)) {
        chop($zone);
        $zone =~ s/^.\///;
        push @zones, $zone;
    } ## end while (defined($zone = <ZONES>...))
    close ZONES;
    my @zt = sort @zones;
    return \@zt;
} ## end sub getZone_list

sub getTimezone {

    #--------------------------------------------------
    # Figure out time zone by looking first looking at
    # the configuration database value of TimeZone.
    # If that is not defined, try and get it from /etc/localtime.
    # If that doesn't work, default to US/Eastern.
    #--------------------------------------------------
    my $localtime;
    my $timezonedefault = "US/Eastern";

    if (defined $cdb->get('TimeZone')) {
        $timezonedefault = $cdb->get('TimeZone')->value;
    } else {

        if (defined($localtime = readlink '/etc/localtime')) {
            my $pos = index $localtime, 'zoneinfo/';

            if ($pos > -1) {
                $timezonedefault = substr $localtime, ($pos + 9);
            }
        } ## end if (defined($localtime...))
    } ## end else [ if (defined $cdb->get(...))]
    return $timezonedefault;
} ## end sub getTimezone

sub validate_change_datetime {
    my $c = shift;
    $cdb = esmith::ConfigDB::UTF8->open() || die "Couldn't open config db";

    #--------------------------------------------------
    # Untaint parameters and check for validity
    #--------------------------------------------------
    my $timezone = $c->param('Timezone');

    if ($timezone =~ /^([\w\-]+\/?[\w\-+]*)$/) {
        $timezone = $1;
    } else {
        $timezone = "US/Eastern";
    }
    my $month = $c->param('month');
    my $day = $c->param('day');
    my $year = $c->param('year');
    if (!is_valid_date($year, $month, $day)){
		return $c->l('dat_Invalid_date')
	}

    my $hour = $c->param('hour');

    if ($hour =~ /^(\d{1,2})$/) {
        $hour = $1;
    } else {
        $hour = "12";
    }

    if (($hour < 1) || ($hour > 23)) {
        return $c->l('dat_INVALID_HOUR') . " $hour. " . $c->l('dat_BETWEEN_0_AND_23');
    }
    my $minute = $c->param('minute');

    if ($minute =~ /^(\d{1,2})$/) {
        $minute = $1;
    } else {
        $minute = "0";
    }

    if (($minute < 0) || ($minute > 59)) {
        return $c->l('datINVALID_MINUTE') . " $minute. " . $c->l('dat_BETWEEN_0_AND_59');
    }
    my $second = $c->param('second');

    if ($second =~ /^(\d{1,2})$/) {
        $second = $1;
    } else {
        $second = "0";
    }

    if (($second < 0) || ($second > 59)) {
        return $c->l('dat_INVALID_SECOND') . " $second. " . $c->l('dat_BETWEEN_0_AND_59');
    }

    #--------------------------------------------------
    # Store time zone in configuration database
    #--------------------------------------------------
    my $old  = $cdb->get('UnsavedChanges')->value;
    my $rec  = $cdb->get('TimeZone');

    unless ($rec) {
        $rec = $cdb->new_record('TimeZone', undef);
    }
    $rec->set_value($timezone);
    $cdb->get('UnsavedChanges')->set_value($old);

    #--------------------------------------------------
    # Signal event to change time zone, system time
    # and hardware clock
    #--------------------------------------------------
    my $newdate = sprintf "%02d%02d%02d%02d%04d.%02d", $month, $day, $hour, $minute, $year, $second;
    $c->app->log->info("Changing date manually to $newdate");
    esmith::util::backgroundCommand(2, "/sbin/e-smith/signal-event", "timezone-update", $newdate); #TEMP!!!
    return '';
} ## end sub validate_change_datetime

sub is_valid_date {
  my ($year, $month, $day) = @_;

  # Check if all parts are defined and integers
  return 0 unless defined $year && defined $month && defined $day;
  return 0 unless $year =~ /^\d+$/ && $month =~ /^\d+$/ && $day =~ /^\d+$/;

  # Try to construct a DateTime object
  eval {
    DateTime->new(year => $year, month => $month, day => $day);
    1;
  } or return 0;

  return 1;
}

sub update_ntpserver {
    my $c         = shift;
    my $ntpserver = shift;
    my $msg = '';
    $cdb = esmith::ConfigDB::UTF8->open() || die "Couldn't open config db";

    #------------------------------------------------------------
    # Looks good; go ahead and change the parameters.
    #------------------------------------------------------------
    my $old = $cdb->get('UnsavedChanges')->value;
    my $rec = $cdb->get('ntpd');

    if ($rec) {
        $rec->set_prop('status',    'enabled');
        $rec->set_prop('NTPServer', $ntpserver);
    } else {
        $rec = $cdb->new_record('ntpd',
            { type => 'service', status => 'enabled', SyncToHWClockSupported => 'yes', NTPServer => $ntpserver });
    }
    $cdb->get('UnsavedChanges')->set_value($old);
    $msg = ''; #$c->l('dat_SETTINGS_CHANGED');

    if ($ntpserver =~ /^\s*$/) {
        $rec->set_prop('status', ($rec->prop('SyncToHWClockSupported') || 'yes') eq 'yes' ? 'enabled' : 'disabled');
        $rec->set_prop('NTPServer', '');
        $msg = $c->l('dat_INVALID_NTP_SERVER') if ($rec->prop('SyncToHWClockSupported') || 'yes') ne 'yes';
    } ## end if ($ntpserver =~ /^\s*$/)
    esmith::util::backgroundCommand(2, "/sbin/e-smith/signal-event", "timeserver-update");
    return $msg;
} ## end sub update_ntpserver

sub disable_ntp {

    # make sure that the parameters are set for disabled
    my $old = $cdb->get('UnsavedChanges')->value;
    $cdb = esmith::ConfigDB::UTF8->open() || die "Couldn't open config db";
    my $rec = $cdb->get('ntpd');

    if ($rec) {
        $rec->set_prop('status', ($rec->prop('SyncToHWClockSupported') || 'yes') eq 'yes' ? 'enabled' : 'disabled');
        $rec->set_prop('NTPServer', '');
    } else {
        $rec = $cdb->new_record('ntpd',
            { type => 'service', status => 'enabled', SyncToHWClockSupported => 'yes', NTPServer => '' });
    }
    $cdb->get('UnsavedChanges')->set_value($old);
    return '';
} ## end sub disable_ntp

1;